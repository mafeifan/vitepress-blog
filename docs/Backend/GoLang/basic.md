## `=` 和 `:=` 的区别


| 特性 | `=` | `:=` |
|------|-----|------|
| **用途** | 给已声明变量赋值 | 声明并赋值新变量 |
| **类型** | 需要预先声明类型 | 自动类型推断 |
| **使用范围** | 包级别和函数内 | 仅函数内 |
| **重复声明** | 可以重复赋值 | 不能重复声明同名变量 |

### 实际开发建议

* 优先使用 :=：在函数内部，:= 更简洁
* 包级别变量用 var：全局变量必须用 var 声明
* 需要零值初始化时用 var：如 var count int (自动为0)
* 明确指定类型时用 var：如 var pi float32 = 3.14


## 为什么结构体作为函数参数，前面要加 *

1. 减少内存开销
如果不加 *，函数调用时会复制整个结构体，占用额外内存。
使用 * 可以传递结构体的地址，避免复制，提高性能，尤其是结构体较大时。
2. 修改原始结构体
如果函数需要修改结构体的字段值，必须使用指针才能生效。
不使用指针（即传值方式），函数内部对结构体的修改不会影响原始结构体。
3. 一致性
在 Go 中，方法可以有指针接收者（func (f *Family)）或值接收者（func (f Family)）。
如果你希望无论调用者是结构体变量还是指针，都能统一处理，通常会使用指针接收者。

## 下面两个写法等价吗

```bash
type Person struct {
	Name string
	Age  int
}

// 方法 - 表示这是 Person 的行为
func (p Person) say() {
  fmt.Println("hello world")
}

// 函数 - 表示这是一个独立的操作
func say(p Person) {
  fmt.Println("hello world")
}

// 方法调用 - 面向对象风格
person.say()

// 函数调用 - 函数式风格  
say(person)
```



## any

any 是 interface{} 的别名，Go 1.18+ 引入
any 类型，它表示任何类型，包括 nil。
